Scope:
Scope refers to the 'place' a variable is in. Think of each function/object as a bag that can hold variables and other functions/objects (more bags). Whether or not you can access a variable depends a lot on the scope (which bag(s)) your variable is in. A variable that you can access from anywhere is called a global variable - they sound great when you're first starting to code and your programs are simple, but when things get complex global variables are more trouble than they are worth - especially if you have more than one person working on the code.

Note that JavaScript does not use block-level scope. In many other programming languages, the scope of a variable is affected not only by functions and objects, but also by blocks of code. A block is any place between { and }, like in an if statement, or a for loop. JavaScript does not use block-level scope* - only functions and objects have scope.

This post deals only with the 'var' keyword for defining variables, not 'let' or 'const'. 'let' Is affected by block-level scope.

Look at this snippet of code:

function grandma() {

  var breakfast = "prunes";

  function mother() {

    var dessert = "ice cream";
    var treat = "muffins";

    function child() {

      var food = "pizza";
      var treat = "candy";

      alert(food); //this will output pizza
      alert(dessert); //this will output ice cream
      alert(breakfast); //this will output prunes
      alert(treat); //this will output candy
    }
  }
}

Let's take a look at this, bearing in mind that we are firing all our alerts from inside the 'Child' function:

You can reach food ("pizza") from Child because food was declared inside Child. A function has access to variables declared inside it.

You can reach dessert ("Ice Cream") from Child because dessert was declared in a 'parent' scope of Child (a scope that Child was created in, or maybe somewhere further up Child's 'family').

You can also reach breakfast ("prunes") from child for the same reason.

The last example is an interesting one. 'treat' is the name of a variable in Mother as well as Child. We can access both of those scopes, so which one gets used?
JavaScript looks at the most local scope first. If I have a treat already, why do I need to go looking for a different one? This is the same thing as how JavaScript treated 'food' - 'food' already exists inside Child, so there's no need to even look elsewhere for it.
If JavaScript doesn't find a variable on the inside, then it looks outside (in the parent scope) - this is what happened with 'dessert'. Child didn't have any dessert, so we looked elsewhere. If there had been a variable named 'dessert' on the inside, JavaScript would have picked that one first and stopped looking. That is what it does with 'treat' - it finds candy and stops looking.

What about scope where the variable is in a lower scope than where you are trying to use it?

It's very simple - if a variable has been declared in a 'child' scope from where you are, you can't access it. However, a variable created at or above the scope where you are and changed in a lower scope will retain its changes, like this:

function mother () {

  var dessert = "ice cream";

  function child () {

  var food = "pizza";
  var dessert = "cake";
  }

  alert(food); //undefined
  alert(dessert); //will output 'cake'
}

Food was declared inside a lower scope, so we couldn't reach it, but dessert was declared in the scope we're working from. It got changed by the lower scope, but we can still access it from here.

A couple of last things about scope and variables:

It is possible to use a variable without declaring it in JavaScript - ie, I could say  food = "pizza"; without declaring food. This is considered bad practice, because it automatically makes that variable a global variable, and therefore far more likely to interact badly with other code. Always declare your variables.

this brings us to the last point - use Strict Mode. JavaScript on it's own is pretty laid-back - which is awesome when you need flexibility, but can make you tear your hair out when you're trying to track down a bug and it keeps doing things it's not supposed to be able to do. It's surprisingly easy to accidentally declare a variable as undefined - then, if you try to reassign that variable to something else later on (of course not using the 'var' keyword since it's already defined) JavaScript will create a new global variable, which begins to silently wreak havoc on your code. Strict Mode will catch this and throw an error.
I won't write in depth about Strict Mode here, but it provides structure for a few other things too. Using it is a great habit to get into and will save you many headaches down the road - especially when your code gets more complex.
